<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mr Master - Arduino Project</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="bg-image"></div>

    <!-- Logo Animation Screen -->
    <div id="logoAnimationScreen" class="logo-animation-screen">
        <video id="logoAnimation" autoplay muted>
            <source src="logoanimation.mp4" type="video/mp4">
        </video>
    </div>

    <!-- Main Container -->
    <div id="mainContainer" class="main-container hidden">
        <!-- Background Animation -->
        <div class="animated-background"></div>
        
        <!-- Master Logo -->
        <div id="masterLogo" class="master-logo hidden">
            <img src="master1.png" alt="Master Logo">
        </div>
<!-- Master Sidebar (PASTE HERE) -->
<div id="masterSidebar" class="master-sidebar">
  <div class="sidebar-content">
    <h1>CONTACT US</h1>
    <p>support.mrmaster@gmail.com</p>
  </div>
</div>
        <!-- Sidebar Overlay -->
<div id="sidebarOverlay" class="sidebar-overlay"></div>
        
        <!-- Main Screen -->
        <div id="mainScreen" class="screen active">
            <div class="button-container">
                <button class="main-btn" onclick="navigateToScreen('codeScreen')">
                    <span>Code</span>
                </button>
                <button class="main-btn" onclick="navigateToScreen('diagramScreen')">
                    <span>Diagram</span>
                </button>
                <button class="main-btn" onclick="navigateToScreen('projectInfoScreen')">
                    <span>Project Info</span>
                </button>
            </div>
        </div>

        <!-- Code Screen -->
        <div id="codeScreen" class="screen">
            <button class="back-btn" onclick="navigateToScreen('mainScreen')">←</button>
            <div class="code-container">
                <h2>Full Code</h2>
                <div class="code-box" id="codeBox">
                    <pre><code>#include&lt;SoftwareSerial.h&gt;

SoftwareSerial Serial1(2,3); //make RX arduino line is pin 2, make TX arduino line is pin 3.

SoftwareSerial gps(10,11);

#include&lt;LiquidCrystal.h&gt;

LiquidCrystal lcd(4,5,6,7,8,9);

#define x A1

#define y A2

#define z A3

int xsample=0;

int ysample=0;

int zsample=0;

#define samples 10

#define minVal -50

#define MaxVal 50

int i=0,k=0;

int  gps_status=0;

float latitude=0; 

float logitude=0;                       

String Speed="";

String gpsString="";

char *test="$GPRMC";

void initModule(String cmd, char *res, int t)

{

  while(1)

  {

    Serial.println(cmd);

    Serial1.println(cmd);

    delay(100);

    while(Serial1.available()>0)

    {

       if(Serial1.find(res))

       {

        Serial.println(res);

        delay(t);

        return;

       }

       else

       {

        Serial.println("Error");

       }

    }

    delay(t);

  }

}

void setup() 

{

  Serial1.begin(9600);

  Serial.begin(9600);

  lcd.begin(16,2);  

  lcd.print("Accident Alert  ");

  lcd.setCursor(0,0);

  lcd.print("     System     ");

  delay(2000);

  lcd.clear();

  lcd.print("Initializing");

  lcd.setCursor(0,1);

  lcd.print("Please Wait...");

  delay(1000);

  

  Serial.println("Initializing....");

  initModule("AT","OK",1000);

  initModule("ATE1","OK",1000);

  initModule("AT+CPIN?","READY",1000);  

  initModule("AT+CMGF=1","OK",1000);     

  initModule("AT+CNMI=2,2,0,0,0","OK",1000);  

  Serial.println("Initialized Successfully");

  lcd.clear();

  lcd.print("Initialized");

  lcd.setCursor(0,0);

  lcd.print("Successfully");

  delay(2000);

  lcd.clear();

  lcd.print("Callibrating ");

  lcd.setCursor(0,1);

  lcd.print("Acceleromiter");

  for(int i=0;i&lt;samples;i++)

  {

    xsample+=analogRead(x);

    ysample+=analogRead(y);

    zsample+=analogRead(z);

  }

  xsample/=samples;

  ysample/=samples;

  zsample/=samples;

  Serial.println(xsample);

  Serial.println(ysample);

  Serial.println(zsample);

  delay(1000);

  

  lcd.clear();

  lcd.print("Waiting For GPS");

  lcd.setCursor(0,1);

  lcd.print("     Signal    ");

  delay(2000);

  gps.begin(9600);

  get_gps();

  show_coordinate();

  delay(2000);

  lcd.clear();

  lcd.print("GPS is Ready");

  delay(1000);

  lcd.clear();

  lcd.print("System Ready");

  Serial.println("System Ready..");

}

void loop() 

{

    int value1=analogRead(x);

    int value2=analogRead(y);

    int value3=analogRead(z);

    int xValue=xsample-value1;

    int yValue=ysample-value2;

    int zValue=zsample-value3;

    

    Serial.print("x=");

    Serial.println(xValue);

    Serial.print("y=");

    Serial.println(yValue);

    Serial.print("z=");

    Serial.println(zValue);

    if(xValue &lt; minVal || xValue &gt; MaxVal  || yValue &lt; minVal || yValue &gt; MaxVal  || zValue &lt; minVal || zValue &gt; MaxVal)

    {

      get_gps();

      show_coordinate();

      lcd.clear();

      lcd.print("Sending SMS");

      Serial.println("Sending SMS");

      Send();

      Serial.println("SMS Sent");

      delay(2000);

      lcd.clear();

      lcd.print("System Ready");

    }       

}

void gpsEvent()

{

  gpsString="";

  while(1)

  {

   while (gps.available()>0)            //Serial incoming data from GPS

   {

    char inChar = (char)gps.read();

     gpsString+= inChar;                    //store incoming data from GPS to temparary string str[]

     i++;

    // Serial.print(inChar);

     if (i &lt; 7)                      

     {

      if(gpsString[i-1] != test[i-1])         //check for right string

      {

        i=0;

        gpsString="";

      }

     }

    if(inChar=='
')

    {

     if(i>60)

     {

       gps_status=1;

       break;

     }

     else

     {

       i=0;

     }

    }

  }

   if(gps_status)

    break;

  }

}

void get_gps()

{

  lcd.clear();

  lcd.print("Getting GPS Data");

  lcd.setCursor(0,1);

  lcd.print("Please Wait.....");

   gps_status=0;

   int x=0;

   while(gps_status==0)

   {

    gpsEvent();

    int str_lenth=i;

    coordinate2dec();

    i=0;x=0;

    str_lenth=0;

   }

}

void show_coordinate()

{

    lcd.clear();

    lcd.print("Lat:");

    lcd.print(latitude);

    lcd.setCursor(0,1);

    lcd.print("Log:");

    lcd.print(logitude);

    Serial.print("Latitude:");

    Serial.println(latitude);

    Serial.print("Longitude:");

    Serial.println(logitude);

    Serial.print("Speed(in knots)=");

    Serial.println(Speed);

    delay(2000);

    lcd.clear();

    lcd.print("Speed(Knots):");

    lcd.setCursor(0,1);

    lcd.print(Speed);

}

void coordinate2dec()

{

  String lat_degree="";

    for(i=20;i&lt;=21;i++)         

      lat_degree+=gpsString[i];

      

  String lat_minut="";

     for(i=22;i&lt;=28;i++)         

      lat_minut+=gpsString[i];

  String log_degree="";

    for(i=32;i&lt;=34;i++)

      log_degree+=gpsString[i];

  String log_minut="";

    for(i=35;i&lt;=41;i++)

      log_minut+=gpsString[i];

    

    Speed="";

    for(i=45;i&lt;48;i++)          //extract longitude from string

      Speed+=gpsString[i];

      

     float minut= lat_minut.toFloat();

     minut=minut/60;

     float degree=lat_degree.toFloat();

     latitude=degree+minut;

     

     minut= log_minut.toFloat();

     minut=minut/60;

     degree=log_degree.toFloat();

     logitude=degree+minut;

}

void Send()

{ 

   Serial1.println("AT");

   delay(500);

   serialPrint();

   Serial1.println("AT+CMGF=1");

   delay(500);

   serialPrint();

   Serial1.print("AT+CMGS=");

   Serial1.print('"');

   Serial1.print("Enter your mobile nomber");//rough firstly

   Serial1.println('"');

   delay(500);

   serialPrint();

   Serial1.print("Latitude:");

   Serial1.println(latitude);

   delay(500);

   serialPrint();

   Serial1.print(" longitude:");

   Serial1.println(logitude);

   delay(500);

   serialPrint();

   Serial1.print(" Speed:");

   Serial1.print(Speed);

   Serial1.println("Knots");

   delay(500);

   serialPrint();

   Serial1.print("https://maps.app.goo.gl/9rUqTGt4GLdcr1aM6");

   Serial1.print(latitude,6);

   Serial1.print("+");      //18.490866,73.843418

   Serial1.print(logitude,6);

   Serial1.write(26);

   delay(2000);

   serialPrint();

}

void serialPrint()

{

  while(Serial1.available()>0)

  {

    Serial.print(Serial1.read());

  }

}</code></pre>
                </div>
                <button class="copy-btn" onclick="copyCode()">Copy</button>
            </div>
        </div>

        <!-- Diagram Screen -->
        <div id="diagramScreen" class="screen">
            <button class="back-btn" onclick="navigateToScreen('mainScreen')">←</button>
            <div class="diagram-container">
                <h2>Diagram</h2>
                <div class="diagram-box">
                    <img src="diagram.png" alt="Circuit Diagram" class="diagram-img">
                </div>
            </div>
        </div>

        <!-- Project Info Screen -->
        <div id="projectInfoScreen" class="screen">
            <button class="back-btn" onclick="navigateToScreen('mainScreen')">←</button>
            <div class="info-container">
                <div class="info-content">
                    <h3>Welcome to Mr Master.</h3>
                    <h3>REAL-TIME VEHICLE ACCIDENT ALERT SYSTEM - COMPREHENSIVE PROJECT DESCRIPTION<h3> <p>The Real-Time Vehicle Accident Alert System is an innovative IoT-based safety solution designed to provide immediate emergency response in the critical moments following a vehicular accident. This system leverages embedded microcontroller technology combined with advanced sensors and wireless communication modules to detect accidents automatically and alert emergency services and family members with precise location data within seconds of impact.</p> <h3>SYSTEM OVERVIEW AND PURPOSE</h3> <p>The primary objective of this project is to maximize passenger survival rates by enabling rapid emergency medical intervention. Traditional accident response systems rely on manual reporting by witnesses or survivors, which introduces dangerous delays of several minutes or even hours. This automated system eliminates human reaction time, ensuring that emergency responders receive immediate notification with exact geographic coordinates the moment an accident occurs. The system transforms a vehicle into an intelligent safety device that actively communicates the critical information needed for emergency services to locate and assist victims before irreversible medical complications develop.</p> <h3>CORE TECHNICAL ARCHITECTURE</h3> <p>The system operates on a distributed processing model with the Arduino Uno microcontroller serving as the central processing unit that orchestrates all system components. The Arduino Uno manages real-time sensor data acquisition, processes complex decision logic for accident detection, controls communication protocols, and manages display outputs simultaneously. This microcontroller was chosen for its reliability, extensive community support, processing capability sufficient for real-time applications, and compatibility with all required peripheral modules.</p> <h3>PRIMARY COMPONENTS AND FUNCTIONAL SPECIFICATIONS:ACCELERATION DETECTION MODULE - ADXL335 ACCELEROMETER</h3> <p>The ADXL335 tri-axial accelerometer forms the sensory foundation of the accident detection system. This sophisticated component continuously monitors acceleration changes across three dimensional axes: the X-axis (lateral acceleration), Y-axis (vertical/perpendicular acceleration), and Z-axis (longitudinal/forward-backward acceleration). The sensor samples vehicle motion in real-time, capturing minute-to-minute vibrations during normal driving and immediately detecting dramatic acceleration anomalies characteristic of collision impacts.</p> <p>The ADXL335 operates with exceptional sensitivity, featuring low power consumption of approximately 350 microamperes, making it ideal for vehicle installations powered by standard automotive electrical systems. The module provides analog voltage outputs proportional to acceleration values on each axis, which the Arduino converts to digital signals through its analog-to-digital converter. The system establishes sensitivity thresholds (typically ranging from Â±50 to Â±200 units depending on calibration) that distinguish normal driving vibrations from collision impacts. When acceleration values on any axis exceed these predefined thresholds simultaneously, the microcontroller interprets this as an accident event and immediately initiates emergency protocols.</p> <h3>LOCATION ACQUISITION MODULE - GPS NEO-6M</h3> <p>The GPS Neo-6M module provides precise global positioning capability essential for guiding emergency responders to the accident location. This receiver maintains continuous contact with the GPS satellite constellation, acquiring latitude and longitude coordinates accurate within 2-5 meters under typical conditions. The GPS module communicates with the Arduino through a serial interface at 9600 baud, transmitting NMEA sentences containing comprehensive positional and temporal data.</p> <p>The system specifically extracts the $GPGGA string from the GPS data stream, which contains the essential position fix information including latitude, longitude, altitude, number of satellites in view, and dilution of precision. The Arduino parses this string in real-time, validating data integrity before processing. GPS signals require several seconds to establish an initial fix after system startup; the system maintains continuous tracking even during vehicle movement, ensuring location accuracy is maintained throughout journeys. The GPS module automatically updates position coordinates every second, meaning that at the precise moment of accident detection, current location coordinates are immediately available for transmission.</p> <h3>EMERGENCY COMMUNICATION MODULE - GSM MODULE</h3> <p>The GSM module (utilizing either SIM900A or SIM800L specifications) provides cellular-based wireless communication to transmit alert messages to emergency services and family members. The GSM module functions as a complete mobile telephone device integrated into the system, maintaining continuous connection to available cellular networks. The module communicates with the Arduino through serial protocols, accepting AT commands to perform telecommunications functions.</p> <p>Upon accident detection, the Arduino programmatically commands the GSM module to compose and transmit SMS messages to pre-configured recipient numbers. These recipients typically include emergency services (police/ambulance), family contacts, and optional hospital networks depending on regional integration. The SMS message contains multiple critical information elements: a description of the accident type, the vehicle speed at impact (provided by GPS), the precise geographic coordinates (latitude and longitude), and most importantly, an automatically generated Google Maps hyperlink that directs recipients to the exact accident location on their mobile devices.</p> <p>The Google Maps link construction process leverages the GPS coordinates through the standard format: https://www.google.com/maps/search/?api=1&query=latitude,longitude. Recipients can click this link directly from their SMS message, instantly viewing the accident location, nearby streets, and surrounding landmarks, eliminating any possibility of misrouting or location confusion.</p> <h3>INFORMATION DISPLAY MODULE - 16X2 LCD DISPLAY</h3> <p>The 16x2 character LCD display provides real-time visual feedback about system status and operational parameters to vehicle occupants and maintenance personnel. The display continuously shows critical information including current vehicle speed (in knots, derived from GPS data), GPS satellite signal quality, current GPS coordinates (latitude and longitude), GSM signal strength indicator, system status messages, and emergency alert confirmations.</p> <p>During normal operation, the display cycles through information screens showing navigation status and system health. Upon accident detection, the display immediately changes to show emergency mode indicators, flashing alerts, the detected coordinates being transmitted, and confirmation that alert messages have been sent. This provides passengers with immediate reassurance that emergency services have been notified and displays the location information being transmitted on their behalf.</p> <h3>SYSTEM CONTROL MICROCONTROLLER - ARDUINO UNO</h3> <p>The Arduino Uno microcontroller serves as the intelligent orchestrator integrating all system components into a cohesive safety system. This board contains an ATmega328P processor running at 16 MHz clock speed, featuring 14 digital I/O pins, 6 analog input pins, and 1 UART serial interface. The Arduino manages simultaneous tasks through programmed logic: acquiring analog accelerometer signals, maintaining continuous GPS serial communication, controlling GSM module functions through another serial connection, managing LCD display updates, and executing complex accident detection algorithms.</p> <p>The microcontroller's processing architecture divides operations into discrete intervals, sampling accelerometer data at high frequency (typically every 10-50 milliseconds), checking for accident conditions after each sample, and maintaining GPS/GSM communication windows. The Arduino's flash memory stores the complete program code (typically 15-20 kilobytes), RAM preserves operational variables and emergency contact information, and EEPROM retains persistent data such as emergency contact numbers and system configuration parameters.</p> <h3>SYSTEM OPERATION AND ACCIDENT DETECTION LOGIC</h3> <p>The system implements a sophisticated yet efficient accident detection algorithm that distinguishes genuine collision impacts from normal driving vibrations such as speed bumps, pothole strikes, or rough road surfaces. The base detection logic monitors acceleration values on all three axes continuously, comparing instantaneous measurements against calibrated threshold values established during system initialization.</p> <h3>DETECTION THRESHOLD CONFIGURATION</h3> <p>System sensitivity requires adjustment based on vehicle type, suspension characteristics, and expected driving conditions. Heavy vehicles with rigid suspensions may require higher thresholds (threshold value Â±100-150) to avoid false positives from road irregularities, while lighter vehicles or those with softer suspensions may benefit from lower thresholds (Â±50-100) to capture less severe collisions. The detection algorithm typically requires that acceleration magnitude on at least one axis exceeds the threshold value within a short time window (typically 100-300 milliseconds) to trigger accident protocols.</p> <h3>ACCIDENT CONFIRMATION PROCESS</h3> <p>Upon detecting threshold-exceeding acceleration, the Arduino enters a confirmation phase where it monitors for additional acceleration changes, applies smoothing algorithms to filter sensor noise, and verifies that a genuine accident pattern (rather than a single transient spike) is occurring. Only after confirming sustained anomalous acceleration does the system proceed to GPS coordinate acquisition and message transmission.</p> <h3>ALERT MESSAGE GENERATION AND TRANSMISSION</h3> <p>When accident detection occurs, the system executes a precisely choreographed sequence of operations within milliseconds:</p> <h3>COORDINATE ACQUISITION PHASE</h3> <p>The Arduino immediately commands the GPS module to provide the current position fix. If a valid fix is available from recent satellite contact, coordinates are transmitted within 1-2 seconds. If no recent fix exists, the system continues monitoring for GPS data availability while simultaneously initiating communication module activation.</p> <h3>MESSAGE CONSTRUCTION PHASE</h3> <p>The Arduino constructs a formatted SMS message incorporating the accident alert text, vehicle coordinates, current velocity in knots (converted from GPS speed data), and a complete Google Maps URL constructed from latitude and longitude values. Example message format: "VEHICLE ACCIDENT ALERT! Location: https://www.google.com/maps/search/?api=1&query=18.5204,-73.8567 Speed at impact: 45 knots Timestamp: [HH:MM:SS]".</p> <h3>TRANSMISSION PHASE</h3> <p>The Arduino initiates GSM module communication, using AT command sequences to activate SMS functions, configure message recipients from stored emergency numbers, compose the complete message, and transmit via available cellular networks. The system automatically attempts transmission to multiple recipients sequentially, ensuring redundancy in case any single recipient's number is invalid.</p> <h3>ADVANCED FEATURES AND CAPABILITIES</h3> <h3>MULTI-CONTACT EMERGENCY NOTIFICATION</h3> <p>The system maintains storage for multiple emergency recipient numbers, typically including local emergency services, family members, and potentially integrated hospital networks. The Arduino sequences through these contacts automatically, transmitting identical alert messages to each, ensuring that if one contact is unavailable, alternative emergency resources receive the notification.</p> <h3>SPEED-AT-IMPACT REPORTING</h3> <p>Beyond simple location coordinates, the system includes vehicle velocity in its alert messages. This data is extracted from GPS speed calculations and converted from knots (standard GPS units) to kilometers per hour or miles per hour for universal comprehension. Impact velocity is critical information for emergency medical teams, providing immediate indication of accident severity and potential injury classification.</p> <h3>ACCIDENT HISTORY LOGGING</h3> <p>Advanced system implementations incorporate onboard data logging that records detailed accident information including timestamp, precise coordinates, vehicle speed before and at impact, acceleration magnitudes on each axis, and GSM transmission confirmations. This data can be downloaded post-incident for insurance documentation, accident reconstruction analysis, or system improvement purposes.</p> <h3>ADJUSTABLE SENSITIVITY CALIBRATION</h3> <p>The system provides user-accessible calibration routines allowing emergency professionals or fleet managers to adjust threshold sensitivity settings based on vehicle characteristics and operating environments. Parameters are stored in Arduino EEPROM (non-volatile memory), persisting across power cycles.</p> <h3>MANUAL ALERT ACTIVATION</h3> <p>Beyond automatic detection, the system typically includes a manual emergency button that vehicle occupants can press if they experience an accident that the sensors may have missed, or if other emergencies require immediate assistance. This button triggers alert transmission using the same protocols as automatic detection.</p> <h3>REAL-WORLD IMPLEMENTATION CONSIDERATIONS</h3> <h3>INSTALLATION ARCHITECTURE</h3> <p>In practical vehicle integration, the system components are typically integrated into a compact unit mounted in the vehicle cabin near the center console or integrated into the vehicle's existing emergency communication systems. Power connections tap into the vehicle's 12V electrical system through appropriate voltage regulation circuits, as GPS and GSM modules require 3.3-5V regulated power.</p> <h3>GPS SIGNAL ACQUISITION</h3> <p>GPS receivers require clear line-of-sight to the satellite constellation, typically available through standard vehicle windows. Urban environments, tunnels, or dense foliage may temporarily degrade GPS accuracy. The system accommodates these conditions by caching the most recent valid GPS coordinate and transmitting this location if real-time acquisition fails, ensuring alert delivery even in signal-challenged environments.</p> <h3>CELLULAR COVERAGE DEPENDENCY</h3> <p>GSM transmission reliability depends on available cellular network coverage in the accident location. Systems deployed in regions with robust network infrastructure experience consistently reliable alert delivery, while remote or underdeveloped areas may experience transmission delays. Some advanced implementations incorporate backup transmission mechanisms such as GPRS data transmission or satellite communication for critical situations.</p> <h3>ACCURACY AND RESPONSE TIMING</h3> <p>The complete accident detection-to-alert-transmission process typically completes within 3-5 seconds under optimal conditions, with GPS coordinate acquisition contributing 1-2 seconds and GSM transmission requiring 2-3 seconds. This represents a dramatic improvement over manual emergency reporting, where 5-10 minutes typically elapse before emergency services receive notification and begin response procedures.</p> <h3>BROADER SYSTEM APPLICATIONS</h3> <p>While designed primarily for immediate accident response, the system architecture supports expansion to additional safety and tracking applications. The same platform can be adapted for fleet management and vehicle tracking, where position data is transmitted periodically to fleet operations centers. The system can incorporate additional sensors for environmental monitoring (fire detection, fuel leakage), driver behavior analysis (harsh braking detection, speeding alerts), or integration with vehicle telematics systems for comprehensive safety and performance monitoring.</p> <h3>IMPACT ON EMERGENCY RESPONSE AND PASSENGER SAFETY</h3> <p>Statistical analysis of similar systems demonstrates that automated accident notification reduces emergency response dispatch time from typical 10-15 minute intervals to 2-3 minute intervals, with detection-to-response timelines under 10 minutes compared to typical 30-45 minute periods with manual reporting. For severe injuries, this 20-minute-plus advantage in intervention timing can be literally life-saving, substantially improving survival rates and reducing permanent disability risks. The system represents a significant advancement in vehicle safety technology, complementing traditional crash protection systems (airbags, crumple zones) with intelligent emergency communication, ensuring that surviving passengers receive professional medical assistance at the optimal time window for maximum medical efficacy.</p>
                    <h3>ADD MOBILE NUMBER in Program</h3>
                        <div class="screenshot-container">
                        <img src="screenshot.png" alt="Mobile Number Setup" class="screenshot-img">
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="footer">by ©Rajshekhar Rajguru </div>
    </div>

    <!-- Transition Animation Screen -- >
    <div id="transitionScreen" class="transition-screen hidden">
        <video id="transitionAnimation" muted>
            <source src="logoanimation.mp4" type="video/mp4">
        </video>
    </div>

    <script src="script.js"></script>
                        
                        
</body>
    </html>
